---
phase: 01-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/pyproject.toml
  - backend/app/db/__init__.py
  - backend/app/db/connection.py
  - backend/app/db/schema.py
  - backend/app/db/seed.py
  - backend/tests/db/__init__.py
  - backend/tests/db/conftest.py
  - backend/tests/db/test_schema.py
  - backend/tests/db/test_seed.py
  - backend/tests/db/test_connection.py
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Backend starts cleanly with no pre-existing database file and creates all 6 tables automatically"
    - "Default user exists with $10,000 cash and 10 watchlist tickers after first initialization"
    - "Multiple concurrent async operations complete without database-is-locked errors"
    - "Restarting the backend with an existing database preserves all data without re-seeding"
  artifacts:
    - path: "backend/app/db/__init__.py"
      provides: "Public API for database layer"
      exports: ["init_db", "close_db"]
    - path: "backend/app/db/connection.py"
      provides: "aiosqlite connection with WAL mode and busy_timeout"
      contains: "PRAGMA journal_mode=WAL"
    - path: "backend/app/db/schema.py"
      provides: "CREATE TABLE IF NOT EXISTS for all 6 tables"
      contains: "users_profile"
    - path: "backend/app/db/seed.py"
      provides: "Idempotent default user and watchlist seeding"
      contains: "INSERT OR IGNORE"
    - path: "backend/tests/db/test_schema.py"
      provides: "Tests proving all 6 tables are created"
    - path: "backend/tests/db/test_seed.py"
      provides: "Tests proving seed data is correct and idempotent"
    - path: "backend/tests/db/test_connection.py"
      provides: "Tests proving WAL mode, busy_timeout, and concurrent access"
  key_links:
    - from: "backend/app/db/connection.py"
      to: "backend/app/db/schema.py"
      via: "init_db calls create_tables"
      pattern: "create_tables"
    - from: "backend/app/db/connection.py"
      to: "backend/app/db/seed.py"
      via: "init_db calls seed_default_data"
      pattern: "seed_default_data"
    - from: "backend/app/db/__init__.py"
      to: "backend/app/db/connection.py"
      via: "re-exports init_db and close_db"
      pattern: "from .connection import"
---

<objective>
Create the async SQLite database layer with lazy initialization, schema creation, and seed data.

Purpose: Establish the persistence foundation that all backend services (portfolio, watchlist, chat, snapshots) depend on. Without this, no backend state can be stored or retrieved.

Output: A `backend/app/db/` module exposing `init_db(db_path) -> aiosqlite.Connection` and `close_db(db)`, plus comprehensive tests. The module creates all 6 tables and seeds default data idempotently on first call.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-database-foundation/01-RESEARCH.md
@backend/pyproject.toml
@backend/tests/conftest.py
@backend/app/market/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create the async SQLite database module</name>
  <files>
    backend/pyproject.toml
    backend/app/db/__init__.py
    backend/app/db/connection.py
    backend/app/db/schema.py
    backend/app/db/seed.py
    .gitignore
  </files>
  <action>
1. Add aiosqlite dependency:
   ```bash
   cd backend && uv add aiosqlite
   ```

2. Create `backend/app/db/connection.py`:
   - `async def init_db(db_path: str) -> aiosqlite.Connection` that:
     - Creates parent directory with `os.makedirs(os.path.dirname(db_path) or ".", exist_ok=True)`
     - Opens connection with `aiosqlite.connect(db_path, isolation_level=None)`
     - Sets `db.row_factory = aiosqlite.Row`
     - Executes `PRAGMA journal_mode=WAL`
     - Executes `PRAGMA busy_timeout=5000`
     - Executes `PRAGMA foreign_keys=ON`
     - Calls `create_tables(db)` from schema module
     - Calls `seed_default_data(db)` from seed module
     - Returns the connection
   - `async def close_db(db: aiosqlite.Connection) -> None` that calls `await db.close()`

3. Create `backend/app/db/schema.py`:
   - Define `SCHEMA_SQL` as a multi-line string with all 6 `CREATE TABLE IF NOT EXISTS` statements:
     - `users_profile`: id TEXT PK, cash_balance REAL NOT NULL DEFAULT 10000.0, created_at TEXT NOT NULL
     - `watchlist`: id TEXT PK, user_id TEXT NOT NULL DEFAULT 'default', ticker TEXT NOT NULL, added_at TEXT NOT NULL, UNIQUE(user_id, ticker)
     - `positions`: id TEXT PK, user_id TEXT NOT NULL DEFAULT 'default', ticker TEXT NOT NULL, quantity REAL NOT NULL, avg_cost REAL NOT NULL, updated_at TEXT NOT NULL, UNIQUE(user_id, ticker)
     - `trades`: id TEXT PK, user_id TEXT NOT NULL DEFAULT 'default', ticker TEXT NOT NULL, side TEXT NOT NULL, quantity REAL NOT NULL, price REAL NOT NULL, executed_at TEXT NOT NULL
     - `portfolio_snapshots`: id TEXT PK, user_id TEXT NOT NULL DEFAULT 'default', total_value REAL NOT NULL, recorded_at TEXT NOT NULL
     - `chat_messages`: id TEXT PK, user_id TEXT NOT NULL DEFAULT 'default', role TEXT NOT NULL, content TEXT NOT NULL, actions TEXT, created_at TEXT NOT NULL
   - `async def create_tables(db: aiosqlite.Connection) -> None` that calls `await db.executescript(SCHEMA_SQL)`

4. Create `backend/app/db/seed.py`:
   - `async def seed_default_data(db: aiosqlite.Connection) -> None` that:
     - Checks if default user exists with `SELECT id FROM users_profile WHERE id = ?`
     - If not, INSERTs user with id="default", cash_balance=10000.0, created_at=ISO timestamp
     - Uses `INSERT OR IGNORE INTO watchlist` for each of the 10 default tickers: AAPL, GOOGL, MSFT, AMZN, TSLA, NVDA, META, JPM, V, NFLX
     - Each watchlist row: id=uuid4, user_id="default", ticker=ticker, added_at=ISO timestamp
     - Calls `await db.commit()` after all inserts
   - Helper: use `datetime.now(timezone.utc).isoformat()` for timestamps

5. Create `backend/app/db/__init__.py`:
   - Re-export `init_db` and `close_db` from connection module
   - Brief module docstring

6. Append to `.gitignore`:
   - Add `db/finally.db`, `*.db-wal`, `*.db-shm` entries (the current .gitignore has Django-style `db.sqlite3` patterns but not the actual db paths this project uses)
  </action>
  <verify>
  ```bash
  cd backend && uv run python -c "from app.db import init_db, close_db; print('imports OK')"
  ```
  </verify>
  <done>
  The `backend/app/db/` module exists with 4 files. `init_db` and `close_db` import cleanly. aiosqlite is in dependencies. .gitignore covers SQLite files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tests proving all 4 success criteria</name>
  <files>
    backend/tests/db/__init__.py
    backend/tests/db/conftest.py
    backend/tests/db/test_schema.py
    backend/tests/db/test_seed.py
    backend/tests/db/test_connection.py
  </files>
  <action>
1. Create `backend/tests/db/__init__.py` (empty).

2. Create `backend/tests/db/conftest.py`:
   - A `db` fixture that uses `tmp_path` to create an isolated database per test:
     ```python
     @pytest.fixture
     async def db(tmp_path):
         db_path = str(tmp_path / "test.db")
         conn = await init_db(db_path)
         yield conn
         await conn.close()
     ```
   - A `db_path` fixture that returns a tmp path string (for tests that need to call init_db themselves):
     ```python
     @pytest.fixture
     def db_path(tmp_path):
         return str(tmp_path / "test.db")
     ```

3. Create `backend/tests/db/test_schema.py`:
   - `test_all_six_tables_created(db)`: Query sqlite_master, assert all 6 table names present (users_profile, watchlist, positions, trades, portfolio_snapshots, chat_messages)
   - `test_users_profile_columns(db)`: Query `PRAGMA table_info(users_profile)`, verify columns: id, cash_balance, created_at
   - `test_watchlist_unique_constraint(db)`: Insert a duplicate (user_id, ticker) pair, assert it raises IntegrityError
   - `test_positions_unique_constraint(db)`: Insert a duplicate (user_id, ticker) pair, assert it raises IntegrityError

4. Create `backend/tests/db/test_seed.py`:
   - `test_default_user_created(db)`: SELECT from users_profile where id="default", assert cash_balance == 10000.0
   - `test_ten_watchlist_tickers(db)`: SELECT from watchlist where user_id="default", assert 10 rows with the correct ticker symbols
   - `test_seed_is_idempotent(db, db_path)`: Call `init_db(db_path)` on the SAME path a second time (the fixture already called it once). Then verify: user still has cash_balance 10000.0, watchlist still has exactly 10 rows, no duplicates. Close the second connection after check.
   - `test_existing_data_preserved(db, db_path)`: Modify the user's cash_balance to 5000.0, commit. Call `init_db(db_path)` again on the same path. Verify cash_balance is still 5000.0 (not reset to 10000). Close the second connection.

5. Create `backend/tests/db/test_connection.py`:
   - `test_wal_mode_enabled(db)`: Execute `PRAGMA journal_mode` and assert result is "wal"
   - `test_busy_timeout_set(db)`: Execute `PRAGMA busy_timeout` and assert result is 5000
   - `test_foreign_keys_enabled(db)`: Execute `PRAGMA foreign_keys` and assert result is 1
   - `test_row_factory_returns_dict_like(db)`: Insert + select a row, verify you can access columns by name (e.g., `row["cash_balance"]`)
   - `test_concurrent_reads_and_writes(db)`: Use `asyncio.gather` to run 10 write tasks (INSERT into trades) and 10 read tasks (SELECT from trades) concurrently. Assert all complete without errors.
   - `test_creates_parent_directory(tmp_path)`: Call `init_db` with a path inside a non-existent subdirectory (e.g., `tmp_path / "sub" / "dir" / "test.db"`). Assert the database was created successfully (no FileNotFoundError). Close the connection.

6. Run all tests:
   ```bash
   cd backend && uv run --extra dev pytest tests/db/ -v
   ```
   All tests must pass.
  </action>
  <verify>
  ```bash
  cd backend && uv run --extra dev pytest tests/db/ -v --tb=short
  ```
  All tests pass. Then run all existing tests to confirm nothing is broken:
  ```bash
  cd backend && uv run --extra dev pytest -v --tb=short
  ```
  </verify>
  <done>
  All database tests pass. All existing market data tests still pass. The tests prove: (1) fresh DB creates 6 tables, (2) default user + 10 tickers seeded, (3) concurrent async access works without lock errors, (4) re-initialization preserves existing data.
  </done>
</task>

</tasks>

<verification>
Run from the `backend/` directory:

1. **All 6 tables created from scratch:**
   ```bash
   uv run --extra dev pytest tests/db/test_schema.py -v
   ```

2. **Default seed data correct:**
   ```bash
   uv run --extra dev pytest tests/db/test_seed.py -v
   ```

3. **WAL mode, concurrent access, no lock errors:**
   ```bash
   uv run --extra dev pytest tests/db/test_connection.py -v
   ```

4. **Full regression (all tests including existing market data tests):**
   ```bash
   uv run --extra dev pytest -v
   ```
</verification>

<success_criteria>
- `uv run --extra dev pytest tests/db/ -v` runs 12+ tests, all pass
- `uv run --extra dev pytest -v` runs all tests (including 73 market data tests), all pass
- `from app.db import init_db, close_db` works from any Python context in the backend
- `.gitignore` includes `db/finally.db`, `*.db-wal`, `*.db-shm`
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-foundation/01-01-SUMMARY.md`
</output>
