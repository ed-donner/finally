---
phase: 04-app-assembly
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/static_files.py
  - backend/app/main.py
  - backend/static/index.html
  - backend/tests/test_app.py
autonomous: true

must_haves:
  truths:
    - "App starts, initializes DB, loads watchlist into market data source, starts price streaming, starts snapshot task"
    - "All API endpoints accessible under /api/* with correct prefixes (portfolio, watchlist, stream, health)"
    - "GET /api/health returns 200 with {status: healthy}"
    - "Non-API routes serve static index.html (SPA fallback)"
    - "App shuts down cleanly: stops snapshots, stops market data, closes DB"
  artifacts:
    - path: "backend/app/main.py"
      provides: "FastAPI app with lifespan and all route mounting"
      exports: ["app"]
    - path: "backend/app/static_files.py"
      provides: "SPAStaticFiles subclass for SPA fallback"
      exports: ["SPAStaticFiles"]
    - path: "backend/static/index.html"
      provides: "Placeholder page until frontend is built"
    - path: "backend/tests/test_app.py"
      provides: "Integration tests for the assembled app"
  key_links:
    - from: "backend/app/main.py"
      to: "app.db.init_db / app.db.close_db"
      via: "lifespan startup/shutdown"
      pattern: "await init_db|await close_db"
    - from: "backend/app/main.py"
      to: "app.market.create_market_data_source"
      via: "lifespan startup"
      pattern: "create_market_data_source"
    - from: "backend/app/main.py"
      to: "app.watchlist.get_watchlist"
      via: "lifespan loads tickers into market source"
      pattern: "get_watchlist.*start"
    - from: "backend/app/main.py"
      to: "app.portfolio.start_snapshot_task / stop_snapshot_task"
      via: "lifespan startup/shutdown"
      pattern: "start_snapshot_task|stop_snapshot_task"
    - from: "backend/app/main.py"
      to: "create_stream_router, create_portfolio_router, create_watchlist_router"
      via: "app.include_router inside lifespan"
      pattern: "include_router"
    - from: "backend/app/main.py"
      to: "backend/app/static_files.py"
      via: "app.mount with SPAStaticFiles"
      pattern: "SPAStaticFiles.*mount"
---

<objective>
Assemble the FastAPI application entry point that wires together all existing backend subsystems (database, market data, portfolio, watchlist) via a lifespan context manager, mounts all API routes under /api/*, adds a health check, and serves static files for non-API routes.

Purpose: This is the integration layer that turns independent subsystems into a runnable application. After this plan, `uvicorn app.main:app` starts a fully functional backend.

Output: `backend/app/main.py`, `backend/app/static_files.py`, `backend/static/index.html`, `backend/tests/test_app.py`
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-app-assembly/04-RESEARCH.md

@backend/app/db/__init__.py
@backend/app/db/connection.py
@backend/app/market/__init__.py
@backend/app/market/factory.py
@backend/app/market/stream.py
@backend/app/portfolio/__init__.py
@backend/app/portfolio/snapshots.py
@backend/app/routes/portfolio.py
@backend/app/watchlist/__init__.py
@backend/app/watchlist/service.py
@backend/app/watchlist/router.py
@backend/tests/conftest.py
@backend/tests/routes/test_portfolio_routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create main.py, static_files.py, and placeholder static/index.html</name>
  <files>
    backend/app/static_files.py
    backend/app/main.py
    backend/static/index.html
  </files>
  <action>
Create three files:

**backend/app/static_files.py** -- SPAStaticFiles subclass:
- Subclass `starlette.staticfiles.StaticFiles`
- Override `get_response(self, path, scope)`: try `super().get_response(path, scope)`, catch `HTTPException` with status 404, fall back to `super().get_response("index.html", scope)`, re-raise other HTTP exceptions
- Brief docstring explaining SPA fallback purpose

**backend/app/main.py** -- Application entry point:
- Imports: `asynccontextmanager` from contextlib, `FastAPI` from fastapi, `logging`, `os`
- Import from existing modules: `init_db`, `close_db` from `app.db`; `PriceCache`, `create_market_data_source`, `create_stream_router` from `app.market`; `start_snapshot_task`, `stop_snapshot_task` from `app.portfolio`; `create_portfolio_router` from `app.routes.portfolio`; `create_watchlist_router`, `get_watchlist` from `app.watchlist`
- Config via env vars: `DB_PATH = os.environ.get("DB_PATH", "db/finally.db")` and `STATIC_DIR = os.environ.get("STATIC_DIR", "static")`
- `@asynccontextmanager async def lifespan(app: FastAPI)` that does:
  - STARTUP: (1) `db = await init_db(DB_PATH)`, (2) `price_cache = PriceCache()`, (3) `market_source = create_market_data_source(price_cache)`, (4) load watchlist: `rows = await get_watchlist(db)` then `tickers = [r["ticker"] for r in rows]` then `await market_source.start(tickers)`, (5) `await start_snapshot_task(db, price_cache)`, (6) mount routers via `app.include_router(create_stream_router(price_cache))`, `app.include_router(create_portfolio_router(db, price_cache))`, `app.include_router(create_watchlist_router(db, price_cache, market_source))`
  - `yield`
  - SHUTDOWN: `await stop_snapshot_task()`, `await market_source.stop()`, `await close_db(db)`
  - Add logger.info calls for key milestones (starting, ready with ticker count, shutting down, stopped)
- Module-level: `app = FastAPI(title="FinAlly", lifespan=lifespan)`
- Health endpoint registered directly on app: `@app.get("/api/health", tags=["system"])` returning `{"status": "healthy"}`
- Static file mount LAST, guarded by `os.path.isdir(STATIC_DIR)`: `from app.static_files import SPAStaticFiles` then `app.mount("/", SPAStaticFiles(directory=STATIC_DIR, html=True), name="spa")`. Put the guard and import at module level after the health endpoint.

**backend/static/index.html** -- Minimal placeholder:
```html
<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8"><title>FinAlly</title></head>
<body style="background:#0d1117;color:#ecad0a;font-family:monospace;display:flex;justify-content:center;align-items:center;height:100vh;margin:0">
<h1>FinAlly - Loading...</h1>
</body>
</html>
```

Keep all files short and focused. No defensive programming. The lifespan is the only complex piece -- it is pure wiring, no business logic.
  </action>
  <verify>
Run from backend directory:
- `uv run python -c "from app.main import app; print(app.title)"` prints "FinAlly"
- `uv run python -c "from app.static_files import SPAStaticFiles; print('OK')"` prints "OK"
- Confirm `backend/static/index.html` exists
  </verify>
  <done>
    - main.py creates a FastAPI app with lifespan that wires db, market data, portfolio snapshots, and all routers
    - static_files.py provides SPAStaticFiles with SPA fallback
    - static/index.html exists as placeholder
    - Health endpoint registered at /api/health
    - Static mount is last and guarded by os.path.isdir
  </done>
</task>

<task type="auto">
  <name>Task 2: Integration tests for the assembled app</name>
  <files>
    backend/tests/test_app.py
  </files>
  <action>
Add `asgi-lifespan` as a dev dependency: `cd backend && uv add --dev asgi-lifespan`

Create **backend/tests/test_app.py** with integration tests that exercise the full assembled app with lifespan:

**Fixture** `client`:
- Use `monkeypatch` to set `DB_PATH` to a tmp_path db file and delete `MASSIVE_API_KEY` (ensures simulator)
- Import `app` from `app.main` -- but because `app` is module-level and may accumulate state between tests, use a fresh import approach. The simplest reliable approach: import the module, then use `importlib.reload(app.main)` to get a fresh `app` per test. OR: since the lifespan creates and tears down all state, and the module-level `app` object itself is stateless (the state is in the lifespan closures), direct import should be safe as long as `DB_PATH` is monkeypatched before the lifespan runs.
- Wrap with `LifespanManager` from `asgi_lifespan`
- Create `AsyncClient` with `ASGITransport` and `base_url="http://test"`

**Tests** (all using the `client` fixture):

1. `test_health` -- `GET /api/health` returns 200 with `{"status": "healthy"}`

2. `test_watchlist_loaded` -- `GET /api/watchlist` returns 200, response has `count` of 10 (the 10 default seeded tickers)

3. `test_portfolio_initial` -- `GET /api/portfolio` returns 200 with `cash_balance` of 10000.0

4. `test_trade_through_assembled_app` -- `POST /api/portfolio/trade` with `{"ticker": "AAPL", "side": "buy", "quantity": 5}` returns 200, then `GET /api/portfolio` shows cash reduced and AAPL position present

5. `test_static_index` -- `GET /` returns 200 with HTML content containing "FinAlly"

6. `test_static_spa_fallback` -- `GET /some/unknown/path` returns 200 with HTML (SPA fallback to index.html), NOT 404

Important notes for the fixture:
- The `monkeypatch` must set `DB_PATH` env var BEFORE importing the app module, or use `os.environ` patching. Since `DB_PATH` is read at module import time (`DB_PATH = os.environ.get(...)`), use `monkeypatch.setenv("DB_PATH", ...)` and then reload the module, OR set the env var and use a dynamic import. The simplest approach: set env vars via `monkeypatch.setenv`, then `import app.main as main_mod`, `importlib.reload(main_mod)`, and use `main_mod.app`.
- Use `monkeypatch.setenv("STATIC_DIR", str(static_path))` where `static_path` points to a tmp dir containing a copy of `index.html`, OR point to the actual `backend/static` directory using a path relative to the test file.
- Each test function is independent. The fixture creates a fresh DB per test via tmp_path.

Follow the existing test style: simple, direct assertions, no unnecessary abstraction. Use `pytest.fixture` with `async` as the existing tests do.
  </action>
  <verify>
Run all tests from the backend directory:
- `uv run --extra dev pytest tests/test_app.py -v` -- all 6 tests pass
- `uv run --extra dev pytest -v` -- ALL tests pass (existing 139 + new 6 = 145)
  </verify>
  <done>
    - asgi-lifespan added as dev dependency
    - 6 integration tests verify: health check, watchlist loaded from DB, portfolio accessible, trade execution works, static file serving works, SPA fallback works
    - All 145 tests pass (139 existing + 6 new)
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `uv run --extra dev pytest -v` from `backend/` -- all tests pass (145 expected)
2. `uv run python -c "from app.main import app; print(app.title, len(app.routes))"` -- prints "FinAlly" with route count > 0
3. Static placeholder exists at `backend/static/index.html`
</verification>

<success_criteria>
- FastAPI app at `backend/app/main.py` with lifespan that initializes DB, market data, snapshots, and mounts all routers
- Health check at GET /api/health returns {"status": "healthy"}
- SPAStaticFiles serves index.html for non-API routes with SPA fallback
- All 145 tests pass (139 existing + 6 new integration tests)
- App is runnable via `uvicorn app.main:app`
</success_criteria>

<output>
After completion, create `.planning/phases/04-app-assembly/04-01-SUMMARY.md`
</output>
