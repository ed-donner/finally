---
phase: 02-portfolio-trade-execution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/portfolio/__init__.py
  - backend/app/portfolio/models.py
  - backend/app/portfolio/service.py
  - backend/tests/portfolio/__init__.py
  - backend/tests/portfolio/conftest.py
  - backend/tests/portfolio/test_service.py
autonomous: true

must_haves:
  truths:
    - "execute_trade with side=buy deducts cash and creates/updates position atomically"
    - "execute_trade with side=sell adds cash and reduces/removes position atomically"
    - "Buy with insufficient cash raises ValueError with clear message"
    - "Sell with insufficient shares raises ValueError with clear message"
    - "Every trade is recorded in the trades table as an append-only log"
    - "Buying same ticker twice produces correct weighted average cost"
    - "Selling all shares removes the position (no dust)"
    - "get_portfolio returns positions with current prices, unrealized P&L, cash balance, total value"
    - "get_portfolio_history returns timestamped snapshots ordered by time"
  artifacts:
    - path: "backend/app/portfolio/models.py"
      provides: "Pydantic request/response schemas for trade and portfolio"
      contains: "class TradeRequest"
    - path: "backend/app/portfolio/service.py"
      provides: "Business logic: execute_trade, get_portfolio, get_portfolio_history"
      exports: ["execute_trade", "get_portfolio", "get_portfolio_history"]
    - path: "backend/tests/portfolio/test_service.py"
      provides: "Tests proving all trade execution and portfolio query behaviors"
      min_lines: 80
  key_links:
    - from: "backend/app/portfolio/service.py"
      to: "backend/app/market/cache.py"
      via: "price_cache.get_price(ticker)"
      pattern: "price_cache\\.get_price"
    - from: "backend/app/portfolio/service.py"
      to: "backend/app/db/schema.py"
      via: "SQL queries against positions, trades, users_profile, portfolio_snapshots tables"
      pattern: "await db\\.execute"
---

<objective>
Create the portfolio service layer: Pydantic models for request/response schemas, and service functions for trade execution (buy/sell with atomic transactions), portfolio querying (positions with live prices and P&L), and portfolio history retrieval. Prove correctness with comprehensive tests.

Purpose: This is the core business logic for Phase 2. All 8 PORT requirements depend on these service functions. The route layer (Plan 02) will be a thin wrapper around these.

Output: `backend/app/portfolio/` module with models, service, and tests proving trade atomicity, validation, P&L calculation, and query correctness.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-portfolio-trade-execution/02-RESEARCH.md
@.planning/phases/01-database-foundation/01-01-SUMMARY.md
@backend/app/db/connection.py
@backend/app/db/schema.py
@backend/app/db/seed.py
@backend/app/market/cache.py
@backend/tests/db/conftest.py
@backend/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic models and portfolio service with trade execution</name>
  <files>
    backend/app/portfolio/__init__.py
    backend/app/portfolio/models.py
    backend/app/portfolio/service.py
  </files>
  <action>
Create `backend/app/portfolio/` package with three files:

**models.py** -- Pydantic v2 request/response schemas:
- `TradeRequest`: ticker (str, min_length=1, max_length=10), side (str, pattern="^(buy|sell)$"), quantity (float, gt=0)
- `TradeResponse`: ticker, side, quantity, price, total (all the trade execution result fields)
- `PositionResponse`: ticker, quantity, avg_cost, current_price, market_value, unrealized_pnl, unrealized_pnl_percent
- `PortfolioResponse`: cash_balance, positions (list[PositionResponse]), total_value
- `SnapshotResponse`: total_value, recorded_at
- `PortfolioHistoryResponse`: snapshots (list[SnapshotResponse])

**service.py** -- Three async functions, each taking `db: aiosqlite.Connection` and `price_cache: PriceCache` as arguments (dependency injection, no globals):

1. `execute_trade(db, price_cache, ticker, side, quantity) -> dict` --
   - Get current price from `price_cache.get_price(ticker)`. If None, raise `ValueError("No price available for {ticker}")`.
   - Compute `cost = round(current_price * quantity, 2)`.
   - Wrap entire operation in explicit `BEGIN` / `COMMIT` (the db uses `isolation_level=None` so autocommit is on -- explicit transaction required for atomicity).
   - For buy: read cash_balance from users_profile, validate cash >= cost, deduct cash, upsert position using `INSERT ... ON CONFLICT(user_id, ticker) DO UPDATE SET` with weighted average cost formula `(old_avg * old_qty + new_price * new_qty) / (old_qty + new_qty)`. The avg_cost update happens in SQL, not Python.
   - For sell: read position quantity, validate quantity >= requested, add cash, update or delete position. Delete if `new_qty < 0.0001` (floating point dust). On sells, do NOT update avg_cost -- only update quantity and updated_at.
   - Always insert into trades table (append-only log) with uuid4 id, ticker, side, quantity, price, executed_at.
   - On any exception after BEGIN, always ROLLBACK before re-raising.
   - Return dict with ticker, side, quantity, price, total.

2. `get_portfolio(db, price_cache) -> dict` --
   - Read cash_balance from users_profile for user "default".
   - Read all positions for user "default".
   - For each position: get current_price from price_cache; if None, fall back to avg_cost. Compute market_value, unrealized_pnl (market_value - cost_basis), unrealized_pnl_percent ((pnl / cost_basis) * 100, or 0 if cost_basis is 0).
   - Return dict with cash_balance, positions list, total_value (cash + sum of market values).

3. `get_portfolio_history(db) -> dict` -- (does not need price_cache)
   - Query portfolio_snapshots for user "default" ordered by recorded_at ASC.
   - Return dict with snapshots list (each: total_value, recorded_at).

Use `datetime.now(timezone.utc).isoformat()` for timestamps and `str(uuid4())` for IDs -- matching the patterns established in `backend/app/db/seed.py`.

**__init__.py** -- Re-export the three service functions and all model classes for clean imports.

Do NOT:
- Import or use FastAPI in this module (that's Plan 02's route layer)
- Create a context manager wrapper for transactions (over-engineering per research)
- Store db or price_cache as module-level globals
- Use Python-side avg_cost calculation (must be SQL ON CONFLICT formula)
  </action>
  <verify>
    `cd /Users/ed/projects/finally/backend && uv run python -c "from app.portfolio import execute_trade, get_portfolio, get_portfolio_history; from app.portfolio.models import TradeRequest, TradeResponse, PortfolioResponse; print('imports OK')"`
  </verify>
  <done>
    Three files exist. All model classes and service functions importable. No FastAPI dependency in portfolio module.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive service tests proving all trade and portfolio behaviors</name>
  <files>
    backend/tests/portfolio/__init__.py
    backend/tests/portfolio/conftest.py
    backend/tests/portfolio/test_service.py
  </files>
  <action>
Create `backend/tests/portfolio/` package:

**conftest.py** -- Two fixtures:
- `db` fixture: uses `tmp_path`, calls `init_db(str(tmp_path / "test.db"))`, yields connection, closes on teardown. Same pattern as `backend/tests/db/conftest.py`.
- `price_cache` fixture: creates a `PriceCache()` and calls `cache.update("AAPL", 150.00)`, `cache.update("GOOGL", 175.00)`, `cache.update("MSFT", 400.00)`. Returns the cache with known prices for deterministic testing.

**test_service.py** -- Tests covering every requirement. All tests are async (asyncio_mode=auto handles this). Use `from app.portfolio.service import execute_trade, get_portfolio, get_portfolio_history`.

Required tests (minimum):

Buy execution:
- `test_buy_deducts_cash`: Buy 10 AAPL at $150 -> cash goes from $10000 to $8500
- `test_buy_creates_position`: Buy 10 AAPL -> position exists with qty=10, avg_cost=150
- `test_buy_updates_existing_position_weighted_avg`: Buy 10 AAPL at $150, then buy 10 AAPL at $200 -> qty=20, avg_cost=175 (weighted average)
- `test_buy_insufficient_cash`: Buy 100 AAPL at $150 = $15000 > $10000 -> raises ValueError matching "Insufficient cash"

Sell execution:
- `test_sell_adds_cash`: Buy 10 AAPL, sell 5 -> cash = 10000 - 1500 + 750 = 9250
- `test_sell_reduces_position`: Buy 10, sell 5 -> qty=5, avg_cost unchanged at 150
- `test_sell_all_removes_position`: Buy 10, sell 10 -> position row deleted (not just zero qty)
- `test_sell_insufficient_shares`: Sell AAPL without owning any -> raises ValueError matching "Insufficient shares"
- `test_sell_more_than_owned`: Buy 5, sell 10 -> raises ValueError
- `test_sell_does_not_change_avg_cost`: Buy at $150, price changes to $200, sell some -> avg_cost still $150

Trade recording:
- `test_trade_recorded_in_history`: Execute a buy -> trades table has 1 row with correct ticker, side, quantity, price
- `test_multiple_trades_all_recorded`: Execute 3 trades -> trades table has 3 rows

Validation:
- `test_trade_no_price_available`: Trade a ticker not in price_cache -> raises ValueError matching "No price available"
- `test_buy_rolls_back_on_failure`: Attempt a buy that fails validation -> cash unchanged (transaction rolled back)

Portfolio query:
- `test_get_portfolio_empty`: No positions -> returns cash=10000, positions=[], total_value=10000
- `test_get_portfolio_with_positions`: Buy AAPL, query portfolio -> position shows current_price from cache, correct unrealized_pnl
- `test_get_portfolio_price_fallback`: Buy AAPL, remove AAPL from price_cache -> current_price falls back to avg_cost, unrealized_pnl=0
- `test_get_portfolio_total_value`: Buy AAPL and GOOGL -> total_value = cash + AAPL market_value + GOOGL market_value

Portfolio history:
- `test_get_portfolio_history_empty`: No snapshots -> returns empty list
- `test_get_portfolio_history_ordered`: Insert 3 snapshots manually -> returned in chronological order

Run tests: `uv run --extra dev pytest tests/portfolio/ -v`

Do NOT:
- Test routes or HTTP in this plan (that's Plan 02)
- Test the snapshot background task loop (that's Plan 02)
- Use `pytest.mark.asyncio` decorator (asyncio_mode=auto handles it)
- Skip edge cases -- every validation path must have a test
  </action>
  <verify>
    `cd /Users/ed/projects/finally/backend && uv run --extra dev pytest tests/portfolio/ -v`

    All tests must pass. Then verify no regressions:

    `cd /Users/ed/projects/finally/backend && uv run --extra dev pytest -v`
  </verify>
  <done>
    All portfolio service tests pass. Full test suite (db + market + portfolio) passes with zero failures. Tests cover: buy creates/updates position, sell reduces/removes position, insufficient cash/shares rejected, trades recorded, portfolio query with live prices and fallback, portfolio history ordering.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/ed/projects/finally/backend && uv run python -c "from app.portfolio.models import TradeRequest, PortfolioResponse; print(TradeRequest.model_json_schema())"` -- Pydantic models produce valid JSON schemas
2. `cd /Users/ed/projects/finally/backend && uv run --extra dev pytest tests/portfolio/ -v` -- All portfolio tests pass
3. `cd /Users/ed/projects/finally/backend && uv run --extra dev pytest -v` -- Full regression suite passes (db + market + portfolio)
4. `cd /Users/ed/projects/finally/backend && uv run --extra dev ruff check app/portfolio/ tests/portfolio/` -- No lint errors
</verification>

<success_criteria>
- backend/app/portfolio/ exists with models.py, service.py, __init__.py
- execute_trade correctly handles buy (deduct cash, create/update position with weighted avg) and sell (add cash, reduce/delete position, preserve avg_cost)
- Validation rejects insufficient cash, insufficient shares, and missing prices with clear error messages
- Every trade recorded in trades table
- get_portfolio returns positions with live prices (fallback to avg_cost), unrealized P&L, cash balance, total value
- get_portfolio_history returns chronologically ordered snapshots
- All tests pass, full regression green
</success_criteria>

<output>
After completion, create `.planning/phases/02-portfolio-trade-execution/02-01-SUMMARY.md`
</output>
