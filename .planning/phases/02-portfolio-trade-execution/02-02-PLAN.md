---
phase: 02-portfolio-trade-execution
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/app/portfolio/snapshots.py
  - backend/app/routes/portfolio.py
  - backend/tests/portfolio/test_snapshots.py
  - backend/tests/routes/__init__.py
  - backend/tests/routes/test_portfolio_routes.py
autonomous: true

must_haves:
  truths:
    - "GET /api/portfolio returns 200 with cash_balance, positions, and total_value"
    - "POST /api/portfolio/trade with valid buy returns 200 and deducts cash"
    - "POST /api/portfolio/trade with valid sell returns 200 and adds cash"
    - "POST /api/portfolio/trade with insufficient cash returns 400 with error detail"
    - "POST /api/portfolio/trade with insufficient shares returns 400 with error detail"
    - "POST /api/portfolio/trade with invalid input (missing fields, negative qty) returns 422"
    - "GET /api/portfolio/history returns 200 with snapshots array"
    - "record_snapshot computes total_value from cash + positions at current prices and inserts into portfolio_snapshots"
    - "start_snapshot_task creates an asyncio task that records snapshots periodically"
    - "stop_snapshot_task cancels the background task cleanly"
  artifacts:
    - path: "backend/app/routes/portfolio.py"
      provides: "FastAPI router factory for /api/portfolio endpoints"
      contains: "def create_portfolio_router"
    - path: "backend/app/portfolio/snapshots.py"
      provides: "Background snapshot task: record_snapshot, start_snapshot_task, stop_snapshot_task"
      exports: ["record_snapshot", "start_snapshot_task", "stop_snapshot_task"]
    - path: "backend/tests/routes/test_portfolio_routes.py"
      provides: "HTTP-level tests for all portfolio endpoints"
      min_lines: 60
    - path: "backend/tests/portfolio/test_snapshots.py"
      provides: "Tests for snapshot recording and task lifecycle"
      min_lines: 30
  key_links:
    - from: "backend/app/routes/portfolio.py"
      to: "backend/app/portfolio/service.py"
      via: "service.execute_trade, service.get_portfolio, service.get_portfolio_history"
      pattern: "service\\."
    - from: "backend/app/routes/portfolio.py"
      to: "backend/app/portfolio/snapshots.py"
      via: "record_snapshot called after each trade"
      pattern: "record_snapshot"
    - from: "backend/app/portfolio/snapshots.py"
      to: "backend/app/market/cache.py"
      via: "price_cache.get_price for portfolio valuation"
      pattern: "price_cache\\.get_price"
---

<objective>
Create the FastAPI route layer for portfolio endpoints and the background snapshot task. The route layer is a thin wrapper around the service functions from Plan 01. The snapshot module provides periodic portfolio value recording (every 30s) and on-demand recording (after each trade).

Purpose: Completes Phase 2 by exposing the portfolio service as HTTP endpoints and adding the snapshot background task. After this plan, all 8 PORT requirements are satisfied at the API level.

Output: `backend/app/routes/portfolio.py` (HTTP routes), `backend/app/portfolio/snapshots.py` (background task), and comprehensive tests for both.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-portfolio-trade-execution/02-RESEARCH.md
@.planning/phases/02-portfolio-trade-execution/02-01-SUMMARY.md
@backend/app/portfolio/service.py
@backend/app/portfolio/models.py
@backend/app/market/stream.py
@backend/app/db/connection.py
@backend/tests/portfolio/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create snapshot module and portfolio route factory</name>
  <files>
    backend/app/portfolio/snapshots.py
    backend/app/routes/portfolio.py
  </files>
  <action>
**snapshots.py** -- Three public functions for portfolio value snapshots:

1. `record_snapshot(db, price_cache) -> None` --
   - Query all positions for user "default" (ticker, quantity).
   - Query cash_balance from users_profile for user "default".
   - For each position, get price from `price_cache.get_price(ticker)`. If None, skip that position's value (it won't contribute -- this is fine for snapshots since positions without prices are rare edge cases during startup).
   - Compute `total_value = round(cash + sum(price * qty for each position), 2)`.
   - Insert into portfolio_snapshots with uuid4 id, user_id="default", total_value, recorded_at as ISO timestamp.
   - Use single `await db.execute(...)` for the insert -- no transaction needed since it's one statement in autocommit mode.

2. `start_snapshot_task(db, price_cache, interval=30.0) -> asyncio.Task` --
   - Creates an asyncio task running `_snapshot_loop(db, price_cache, interval)`.
   - The loop: `while True: try record_snapshot except Exception log error; await asyncio.sleep(interval)`.
   - Store task reference in module-level `_snapshot_task` variable.
   - Return the task handle.

3. `stop_snapshot_task() -> None` (async) --
   - Cancel `_snapshot_task`, await it with CancelledError handling, set to None.

Use `logging.getLogger(__name__)` for error logging in the loop. Import asyncio, logging, datetime, uuid4.

**routes/portfolio.py** -- Factory function following the exact same pattern as `create_stream_router` in `backend/app/market/stream.py`:

```python
def create_portfolio_router(db, price_cache: PriceCache) -> APIRouter:
```

Define router at module level: `router = APIRouter(prefix="/api/portfolio", tags=["portfolio"])`

Three endpoints inside the factory:

1. `GET /api/portfolio` (response_model=PortfolioResponse) --
   - Calls `service.get_portfolio(db, price_cache)`, returns result.

2. `POST /api/portfolio/trade` (response_model=TradeResponse) --
   - Accepts `TradeRequest` body.
   - Calls `service.execute_trade(db, price_cache, request.ticker, request.side, request.quantity)`.
   - On success, fire `record_snapshot(db, price_cache)` (await it -- immediate snapshot after trade per PORT-07).
   - On `ValueError`, raise `HTTPException(status_code=400, detail=str(e))`.
   - Return the trade result.

3. `GET /api/portfolio/history` (response_model=PortfolioHistoryResponse) --
   - Calls `service.get_portfolio_history(db)`, returns result.

Return the router.

Update `backend/app/portfolio/__init__.py` to also export `record_snapshot`, `start_snapshot_task`, `stop_snapshot_task` from snapshots.

Do NOT:
- Wire the snapshot task into app lifespan (Phase 4 does that)
- Create a separate endpoint for trade history (not in the Phase 2 API spec)
- Use FastAPI BackgroundTasks for the periodic snapshot loop
- Use `asyncio.run()` or create new event loops
  </action>
  <verify>
    `cd /Users/ed/projects/finally/backend && uv run python -c "from app.portfolio.snapshots import record_snapshot, start_snapshot_task, stop_snapshot_task; from app.routes.portfolio import create_portfolio_router; print('imports OK')"`
  </verify>
  <done>
    snapshots.py exports record_snapshot, start_snapshot_task, stop_snapshot_task. routes/portfolio.py exports create_portfolio_router factory. Portfolio __init__.py updated with snapshot exports.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tests for snapshots and portfolio routes</name>
  <files>
    backend/tests/portfolio/test_snapshots.py
    backend/tests/routes/__init__.py
    backend/tests/routes/test_portfolio_routes.py
  </files>
  <action>
**test_snapshots.py** -- Tests for the snapshot module. Use the `db` and `price_cache` fixtures from `tests/portfolio/conftest.py`.

Required tests:
- `test_record_snapshot_cash_only`: No positions, just cash -> snapshot total_value = 10000
- `test_record_snapshot_with_positions`: Buy some shares first (use execute_trade from service), then record_snapshot -> total_value = cash + positions at current prices
- `test_record_snapshot_inserts_row`: Call record_snapshot, query portfolio_snapshots table directly -> has 1 row
- `test_start_stop_snapshot_task`: Start the task with a short interval (0.1s), sleep briefly (0.3s), stop it -> at least 1 snapshot recorded, task is cancelled without error
- `test_stop_snapshot_task_when_not_started`: Calling stop_snapshot_task when no task is running should not raise

**test_portfolio_routes.py** -- HTTP-level tests using httpx AsyncClient + ASGITransport. Create fixtures in the test file itself (not conftest, since route tests have different setup).

Fixtures needed in this file:
- `app` fixture: init_db(tmp_path), create PriceCache with known prices (AAPL=150, GOOGL=175), create FastAPI(), include_router(create_portfolio_router(db, cache)), yield app, close db.
- `client` fixture: `ASGITransport(app=app)` + `AsyncClient(transport=transport, base_url="http://test")`.

Required tests:
- `test_get_portfolio_empty`: GET /api/portfolio -> 200, cash_balance=10000, positions=[], total_value=10000
- `test_post_trade_buy`: POST /api/portfolio/trade with {"ticker": "AAPL", "side": "buy", "quantity": 10} -> 200, verify response has price=150, total=1500
- `test_post_trade_buy_updates_portfolio`: Buy, then GET /api/portfolio -> cash=8500, 1 position, total_value = 8500 + 1500
- `test_post_trade_sell_after_buy`: Buy 10, sell 5 -> 200, verify response
- `test_post_trade_insufficient_cash`: Buy 100 AAPL ($15000) -> 400, detail contains "Insufficient cash"
- `test_post_trade_insufficient_shares`: Sell AAPL without owning -> 400, detail contains "Insufficient shares"
- `test_post_trade_invalid_side`: POST with side="short" -> 422 (Pydantic validation)
- `test_post_trade_negative_quantity`: POST with quantity=-5 -> 422
- `test_post_trade_missing_fields`: POST with {} -> 422
- `test_get_portfolio_history_empty`: GET /api/portfolio/history -> 200, snapshots=[]
- `test_trade_creates_snapshot`: POST a trade, then GET /api/portfolio/history -> has at least 1 snapshot (the immediate post-trade snapshot)

Use `from httpx import ASGITransport, AsyncClient` and `from fastapi import FastAPI`.

Do NOT:
- Test snapshot background loop timing in route tests (that's in test_snapshots.py)
- Use `TestClient` from Starlette (use httpx AsyncClient for async compatibility)
- Add `pytest.mark.asyncio` decorators (asyncio_mode=auto)
  </action>
  <verify>
    `cd /Users/ed/projects/finally/backend && uv run --extra dev pytest tests/portfolio/ tests/routes/ -v`

    Then full regression:

    `cd /Users/ed/projects/finally/backend && uv run --extra dev pytest -v`
  </verify>
  <done>
    All snapshot tests pass. All route tests pass. Full test suite (db + market + portfolio + routes) passes with zero failures. HTTP tests confirm: GET /api/portfolio returns correct structure, POST /api/portfolio/trade handles buy/sell/validation, GET /api/portfolio/history returns snapshots, trades trigger immediate snapshots.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/ed/projects/finally/backend && uv run --extra dev pytest tests/portfolio/ tests/routes/ -v` -- All new tests pass
2. `cd /Users/ed/projects/finally/backend && uv run --extra dev pytest -v` -- Full regression green
3. `cd /Users/ed/projects/finally/backend && uv run --extra dev ruff check app/portfolio/ app/routes/ tests/portfolio/ tests/routes/` -- No lint errors
4. Verify immediate-after-trade snapshot: the route test `test_trade_creates_snapshot` confirms a snapshot row exists in portfolio_snapshots after POST /api/portfolio/trade
</verification>

<success_criteria>
- GET /api/portfolio returns 200 with positions, cash_balance, total_value
- POST /api/portfolio/trade buy/sell returns 200 with trade details
- POST /api/portfolio/trade with insufficient cash/shares returns 400
- POST /api/portfolio/trade with invalid input returns 422
- GET /api/portfolio/history returns 200 with snapshots list
- Each trade triggers an immediate portfolio snapshot
- Background snapshot task starts/stops cleanly
- Full test suite passes (db + market + portfolio + routes)
</success_criteria>

<output>
After completion, create `.planning/phases/02-portfolio-trade-execution/02-02-SUMMARY.md`
</output>
