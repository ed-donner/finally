---
phase: 03-watchlist-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/watchlist/__init__.py
  - backend/app/watchlist/models.py
  - backend/app/watchlist/service.py
  - backend/app/watchlist/router.py
  - backend/tests/watchlist/__init__.py
  - backend/tests/watchlist/conftest.py
  - backend/tests/watchlist/test_service.py
  - backend/tests/watchlist/test_router.py
autonomous: true

must_haves:
  truths:
    - "GET /api/watchlist returns the 10 seed tickers enriched with live price data from PriceCache"
    - "POST /api/watchlist with a new ticker adds it to the database AND calls market_data_source.add_ticker()"
    - "DELETE /api/watchlist/{ticker} removes it from the database AND calls market_data_source.remove_ticker()"
    - "POST /api/watchlist with a duplicate ticker returns 409"
    - "DELETE /api/watchlist/{ticker} for a non-existent ticker returns 404"
    - "Ticker input is case-insensitive -- 'aapl' and 'AAPL' are treated as the same ticker"
  artifacts:
    - path: "backend/app/watchlist/models.py"
      provides: "Pydantic v2 request/response models"
      contains: "AddTickerRequest"
    - path: "backend/app/watchlist/service.py"
      provides: "Pure async DB functions for watchlist CRUD"
      exports: ["get_watchlist", "add_ticker", "remove_ticker"]
    - path: "backend/app/watchlist/router.py"
      provides: "FastAPI router factory following create_stream_router pattern"
      exports: ["create_watchlist_router"]
    - path: "backend/tests/watchlist/test_service.py"
      provides: "Service layer unit tests"
    - path: "backend/tests/watchlist/test_router.py"
      provides: "HTTP endpoint integration tests"
  key_links:
    - from: "backend/app/watchlist/router.py"
      to: "backend/app/watchlist/service.py"
      via: "Router calls service functions for DB operations"
      pattern: "await (get_watchlist|add_ticker|remove_ticker)"
    - from: "backend/app/watchlist/router.py"
      to: "backend/app/market/interface.py"
      via: "Router calls market_data_source.add_ticker/remove_ticker after DB write"
      pattern: "await market_data_source\\.(add|remove)_ticker"
    - from: "backend/app/watchlist/router.py"
      to: "backend/app/market/cache.py"
      via: "GET endpoint reads PriceCache to enrich watchlist items with live prices"
      pattern: "price_cache\\.get"
---

<objective>
Create the watchlist API: Pydantic models, service layer (pure async DB functions), and FastAPI router factory with three endpoints (GET, POST, DELETE) that manage the watchlist table and sync changes to the MarketDataSource.

Purpose: Enables users to control which tickers they watch. The watchlist drives what the market data source tracks and what prices stream via SSE. This is a critical link between the user's preferences and the live data pipeline.

Output: `backend/app/watchlist/` module with models, service, router + comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@planning/PLAN.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-watchlist-api/03-RESEARCH.md
@.planning/phases/01-database-foundation/01-01-SUMMARY.md

# Existing source files to reference for patterns and types
@backend/app/db/connection.py
@backend/app/db/seed.py
@backend/app/market/interface.py
@backend/app/market/cache.py
@backend/app/market/models.py
@backend/app/market/stream.py
@backend/tests/db/conftest.py
@backend/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create watchlist models and service layer with tests</name>
  <files>
    backend/app/watchlist/__init__.py
    backend/app/watchlist/models.py
    backend/app/watchlist/service.py
    backend/tests/watchlist/__init__.py
    backend/tests/watchlist/conftest.py
    backend/tests/watchlist/test_service.py
  </files>
  <action>
Create the `backend/app/watchlist/` package with three files:

**models.py** -- Pydantic v2 models:
- `AddTickerRequest(BaseModel)`: field `ticker: str` with `Field(..., min_length=1, max_length=10)`.
- `WatchlistItem(BaseModel)`: fields `ticker: str`, `added_at: str`, `price: float | None = None`, `change: float | None = None`, `change_percent: float | None = None`, `direction: str | None = None`.
- `WatchlistResponse(BaseModel)`: fields `items: list[WatchlistItem]`, `count: int`.

**service.py** -- Three pure async functions. Each takes `db: aiosqlite.Connection` as first argument and `user_id: str = "default"`. All ticker inputs normalized with `.upper().strip()` at the top of each function.

1. `get_watchlist(db, user_id)` -- SELECT ticker, added_at FROM watchlist WHERE user_id = ? ORDER BY added_at. Returns `list[dict]` with keys "ticker" and "added_at".

2. `add_ticker(db, ticker, user_id)` -- Generates UUID id, ISO timestamp. INSERT INTO watchlist. Catches `sqlite3.IntegrityError` and raises `fastapi.HTTPException(status_code=409, detail=f"{ticker} is already in the watchlist")`. On success, commits and returns dict with "id", "ticker", "added_at".

3. `remove_ticker(db, ticker, user_id)` -- DELETE FROM watchlist WHERE user_id = ? AND ticker = ?. Checks `cursor.rowcount`. If 0, raises `HTTPException(status_code=404, detail=f"{ticker} is not in the watchlist")`. On success, commits and returns True.

**__init__.py** -- Export `create_watchlist_router` from router (will exist after Task 2), and the three service functions.

**Tests** -- Create `backend/tests/watchlist/` package with:

`conftest.py`:
- `db` fixture: same pattern as `backend/tests/db/conftest.py` (tmp_path, init_db, yield, close).

`test_service.py` (7-8 tests):
- `test_get_watchlist_returns_seed_data(db)` -- 10 items from seed, each has "ticker" and "added_at" keys.
- `test_add_ticker(db)` -- Add "PYPL", verify returned dict has ticker="PYPL", then query DB to confirm row exists.
- `test_add_ticker_normalizes_case(db)` -- Add " pypl ", verify returned ticker is "PYPL".
- `test_add_duplicate_raises_409(db)` -- Add "AAPL" (already seeded), assert HTTPException with status 409.
- `test_remove_ticker(db)` -- Remove "AAPL", returns True, then query DB to confirm row gone.
- `test_remove_ticker_normalizes_case(db)` -- Remove "aapl" succeeds (matches seeded "AAPL").
- `test_remove_nonexistent_raises_404(db)` -- Remove "FAKE", assert HTTPException with status 404.

Use `pytest.raises(HTTPException)` to catch the 409/404 cases, checking `exc_info.value.status_code`.

Do NOT: create classes in service.py (use plain functions), use `response_model` parameter (use return type annotations in Task 2), add any middleware or dependency injection framework.
  </action>
  <verify>
    cd backend && uv run --extra dev pytest tests/watchlist/test_service.py -v
  </verify>
  <done>
    All 7+ service tests pass. Models importable: `from app.watchlist.models import AddTickerRequest, WatchlistItem, WatchlistResponse`. Service functions importable: `from app.watchlist.service import get_watchlist, add_ticker, remove_ticker`. Duplicate add raises 409, missing remove raises 404, case normalization works.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create watchlist router with endpoint tests</name>
  <files>
    backend/app/watchlist/router.py
    backend/tests/watchlist/conftest.py
    backend/tests/watchlist/test_router.py
  </files>
  <action>
**router.py** -- Factory function `create_watchlist_router(db, price_cache, market_data_source) -> APIRouter` following the exact same closure-based pattern as `create_stream_router` in `app/market/stream.py`.

Create `router = APIRouter(prefix="/api/watchlist", tags=["watchlist"])`.

Three endpoints:

1. `GET ""` -> `WatchlistResponse`:
   - Call `service.get_watchlist(db)` to get ticker list from DB.
   - For each ticker, call `price_cache.get(ticker)` to get the `PriceUpdate` (may be None).
   - Build `WatchlistItem` for each: ticker, added_at from DB; price, change, change_percent, direction from PriceUpdate if available (else None).
   - Return `WatchlistResponse(items=items, count=len(items))`.

2. `POST ""` (status_code=201) -> `WatchlistItem`:
   - Accept `AddTickerRequest` body.
   - Call `service.add_ticker(db, request.ticker)` -- this handles normalization, duplicate 409.
   - Call `await market_data_source.add_ticker(ticker)` where ticker is the normalized version (the return dict from add_ticker has the normalized "ticker" key).
   - Return `WatchlistItem(ticker=..., added_at=..., price=None)` -- price will be None because the market data source just started tracking; that is correct.

3. `DELETE "/{ticker}"` (status_code=200):
   - Call `service.remove_ticker(db, ticker)` -- this handles normalization, 404.
   - Call `await market_data_source.remove_ticker(ticker.upper().strip())`.
   - Return `{"removed": ticker.upper().strip()}`.

Return the router.

**Update conftest.py** -- Add fixtures for router tests:

- `mock_market_data_source` fixture: A `MockMarketDataSource` class that implements `MarketDataSource` (import from `app.market.interface`). Has `added: list[str]` and `removed: list[str]` tracking lists. `add_ticker` appends to `added`, `remove_ticker` appends to `removed`. Include `start`, `stop`, `get_tickers` as no-ops/empty returns.

- `price_cache` fixture: Create a `PriceCache()` instance, call `price_cache.update("AAPL", 190.50)` and `price_cache.update("GOOGL", 175.25)` to seed a couple of prices for test enrichment.

- `client` fixture: Build a minimal `FastAPI()` app, call `app.include_router(create_watchlist_router(db, price_cache, mock_market_data_source))`, create `httpx.AsyncClient(transport=ASGITransport(app=app), base_url="http://test")`, yield it, close with `async with`.

- Also yield the `mock_market_data_source` somehow so tests can assert on it. Simplest approach: make `client` fixture return a tuple `(client, mock_source)` or make `mock_market_data_source` a separate session/function fixture that `client` depends on and tests also request.

**test_router.py** (8-9 tests):
- `test_get_watchlist_returns_seed_items` -- GET /api/watchlist, assert 200, body has "items" and "count" == 10.
- `test_get_watchlist_enriches_with_prices` -- GET, find AAPL in items, assert price == 190.50, direction is "flat" (first update has no previous).
- `test_get_watchlist_missing_price_is_null` -- GET, find a ticker NOT in price_cache (e.g., "TSLA"), assert price is None.
- `test_add_ticker` -- POST {"ticker": "PYPL"}, assert 201, body has ticker == "PYPL". Verify mock_market_data_source.added contains "PYPL".
- `test_add_ticker_case_insensitive` -- POST {"ticker": " pypl "}, assert 201, ticker == "PYPL".
- `test_add_duplicate_returns_409` -- POST {"ticker": "AAPL"}, assert 409.
- `test_remove_ticker` -- DELETE /api/watchlist/AAPL, assert 200, body has removed == "AAPL". Verify mock_market_data_source.removed contains "AAPL".
- `test_remove_nonexistent_returns_404` -- DELETE /api/watchlist/FAKE, assert 404.
- `test_add_then_get_shows_new_ticker` -- POST PYPL, then GET, assert count == 11 and PYPL is in the list.

Use `httpx.AsyncClient` with `ASGITransport` as shown in the research doc. No `@pytest.mark.asyncio` decorators needed (asyncio_mode=auto is configured).

Do NOT: use FastAPI's Depends() system (use closure pattern), stream responses, add middleware, add authentication.
  </action>
  <verify>
    cd backend && uv run --extra dev pytest tests/watchlist/ -v && uv run --extra dev pytest -v
  </verify>
  <done>
    All watchlist tests pass (service + router, 15+ tests total). GET /api/watchlist returns 200 with enriched items. POST returns 201 and triggers market_data_source.add_ticker. DELETE returns 200 and triggers market_data_source.remove_ticker. Duplicate add returns 409. Missing remove returns 404. Full backend test suite (db + market + watchlist) passes with no regressions.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, run the full backend test suite to confirm no regressions:

```bash
cd backend && uv run --extra dev pytest -v
cd backend && uv run --extra dev ruff check app/watchlist/ tests/watchlist/
```

Verify imports work cleanly:
```bash
cd backend && uv run python -c "from app.watchlist import create_watchlist_router; print('Router factory OK')"
cd backend && uv run python -c "from app.watchlist.service import get_watchlist, add_ticker, remove_ticker; print('Service OK')"
cd backend && uv run python -c "from app.watchlist.models import AddTickerRequest, WatchlistItem, WatchlistResponse; print('Models OK')"
```
</verification>

<success_criteria>
1. `backend/app/watchlist/` package exists with models.py, service.py, router.py
2. `create_watchlist_router(db, price_cache, market_data_source)` returns an APIRouter with GET/POST/DELETE endpoints
3. GET /api/watchlist returns 200 with seed tickers enriched with PriceCache data
4. POST /api/watchlist with new ticker returns 201 and calls market_data_source.add_ticker()
5. POST /api/watchlist with duplicate ticker returns 409
6. DELETE /api/watchlist/{ticker} returns 200 and calls market_data_source.remove_ticker()
7. DELETE /api/watchlist/{nonexistent} returns 404
8. All tickers normalized to uppercase
9. 15+ tests passing, full backend suite green, ruff clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-watchlist-api/03-01-SUMMARY.md`
</output>
