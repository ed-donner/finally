---
phase: 10-packaging-testing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
  - docker-compose.yml
  - .env.example
  - .dockerignore
  - scripts/start_mac.sh
  - scripts/stop_mac.sh
  - scripts/start_windows.ps1
  - scripts/stop_windows.ps1
autonomous: true

must_haves:
  truths:
    - "docker build produces a working image with frontend static files and Python backend"
    - "docker run on port 8000 serves the frontend at / and API at /api/health"
    - "SQLite data persists across container restarts via a named volume"
    - "start/stop scripts build, run, and teardown the container idempotently"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage build: Node 20 slim frontend, Python 3.12 slim backend"
      contains: "FROM node:20-slim"
    - path: "docker-compose.yml"
      provides: "Convenience wrapper with volume and healthcheck"
      contains: "finally-data"
    - path: ".env.example"
      provides: "Template for required environment variables"
      contains: "OPENROUTER_API_KEY"
    - path: ".dockerignore"
      provides: "Excludes unnecessary files from Docker build context"
      contains: "node_modules"
    - path: "scripts/start_mac.sh"
      provides: "macOS/Linux start script"
      contains: "docker run"
    - path: "scripts/stop_mac.sh"
      provides: "macOS/Linux stop script"
      contains: "docker stop"
    - path: "scripts/start_windows.ps1"
      provides: "Windows start script"
      contains: "docker run"
    - path: "scripts/stop_windows.ps1"
      provides: "Windows stop script"
      contains: "docker stop"
  key_links:
    - from: "Dockerfile"
      to: "frontend/out"
      via: "COPY --from=frontend-builder /app/frontend/out ./static"
      pattern: "COPY --from=frontend-builder.*out.*static"
    - from: "Dockerfile"
      to: "backend/pyproject.toml"
      via: "uv sync --locked"
      pattern: "uv sync --locked"
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build: ."
      pattern: "build:\\s*\\."
---

<objective>
Create the Docker packaging for the FinAlly application: a multi-stage Dockerfile that builds the Next.js frontend and runs it alongside the Python backend, docker-compose.yml for convenience, .env.example for documentation, .dockerignore for build efficiency, and start/stop scripts for macOS/Linux and Windows.

Purpose: This is the PKG-01 through PKG-06 requirements -- packaging the entire app into a single container that serves everything on port 8000.
Output: Dockerfile, docker-compose.yml, .env.example, .dockerignore, 4 shell scripts in scripts/
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-packaging-testing/10-RESEARCH.md

@backend/app/main.py
@backend/pyproject.toml
@frontend/package.json
@frontend/next.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dockerfile, .dockerignore, docker-compose.yml, and .env.example</name>
  <files>Dockerfile, .dockerignore, docker-compose.yml, .env.example</files>
  <action>
Create a multi-stage Dockerfile at the project root:

**Stage 1 (frontend-builder):** FROM node:20-slim
- WORKDIR /app/frontend
- COPY frontend/package.json frontend/package-lock.json ./
- RUN npm ci
- COPY frontend/ ./
- RUN npm run build
- The build output goes to /app/frontend/out (Next.js static export)

**Stage 2 (runtime):** FROM python:3.12-slim
- COPY --from=ghcr.io/astral-sh/uv:latest /uv /uvx /bin/
- WORKDIR /app
- Copy backend/pyproject.toml and backend/uv.lock first for cache layering
- Set ENV UV_COMPILE_BYTECODE=1 UV_LINK_MODE=copy
- RUN --mount=type=cache,target=/root/.cache/uv uv sync --locked --no-install-project --no-dev --no-editable
- COPY backend/ ./ (copies all backend source into /app)
- RUN --mount=type=cache,target=/root/.cache/uv uv sync --locked --no-dev --no-editable
- COPY --from=frontend-builder /app/frontend/out ./static
- RUN mkdir -p /app/db
- Install curl for healthcheck: RUN apt-get update && apt-get install -y --no-install-recommends curl && rm -rf /var/lib/apt/lists/*
- EXPOSE 8000
- CMD ["/app/.venv/bin/uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

**Important filesystem mapping notes:**
- STATIC_DIR defaults to "static" in main.py line 23 -- the COPY maps frontend/out to /app/static
- DB_PATH defaults to "db/finally.db" in main.py line 22 -- /app/db will be the volume mount point
- WORKDIR is /app, so relative paths in the Python code resolve correctly

Create .dockerignore at project root:
```
.git
.env
.planning
.claude
node_modules
__pycache__
*.pyc
.pytest_cache
.ruff_cache
.coverage
htmlcov
db/finally.db
*.db-wal
*.db-shm
frontend/out
frontend/node_modules
frontend/.next
backend/.venv
test/node_modules
*.md
!backend/README.md
```

Create docker-compose.yml at project root:
```yaml
services:
  app:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - finally-data:/app/db
    env_file:
      - .env
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 15s

volumes:
  finally-data:
```

Create .env.example at project root:
```bash
# Required: OpenRouter API key for LLM chat functionality
OPENROUTER_API_KEY=your-openrouter-api-key-here

# Optional: Massive (Polygon.io) API key for real market data
# If not set, the built-in market simulator is used (recommended for most users)
MASSIVE_API_KEY=

# Optional: Set to "true" for deterministic mock LLM responses (testing)
LLM_MOCK=false
```
  </action>
  <verify>
Run: docker build -t finally . (must succeed without errors)
Run: docker run --rm -d --name finally-test -p 8000:8000 -e LLM_MOCK=true finally
Run: curl http://localhost:8000/api/health (must return {"status":"healthy"})
Run: curl -s http://localhost:8000/ | head -5 (must return HTML content)
Run: docker stop finally-test
  </verify>
  <done>
Docker image builds successfully with both stages. Container starts and serves the frontend at / and the health endpoint at /api/health on port 8000. .env.example and .dockerignore exist at project root. docker-compose.yml defines the app service with volume and healthcheck.
  </done>
</task>

<task type="auto">
  <name>Task 2: Start/stop scripts for macOS/Linux and Windows</name>
  <files>scripts/start_mac.sh, scripts/stop_mac.sh, scripts/start_windows.ps1, scripts/stop_windows.ps1</files>
  <action>
Create scripts/ directory if it does not exist.

**scripts/start_mac.sh:**
```bash
#!/usr/bin/env bash
set -euo pipefail

CONTAINER_NAME="finally"
IMAGE_NAME="finally"

# Stop existing container if running
docker rm -f "$CONTAINER_NAME" 2>/dev/null || true

# Build if --build flag passed or image doesn't exist
if [[ "${1:-}" == "--build" ]] || ! docker image inspect "$IMAGE_NAME" &>/dev/null; then
    echo "Building FinAlly Docker image..."
    docker build -t "$IMAGE_NAME" .
fi

# Run container
docker run -d \
    --name "$CONTAINER_NAME" \
    -p 8000:8000 \
    -v finally-data:/app/db \
    --env-file .env \
    "$IMAGE_NAME"

echo ""
echo "FinAlly is running at http://localhost:8000"
echo "Stop with: ./scripts/stop_mac.sh"
```

**scripts/stop_mac.sh:**
```bash
#!/usr/bin/env bash
set -euo pipefail

CONTAINER_NAME="finally"

docker stop "$CONTAINER_NAME" 2>/dev/null && echo "FinAlly stopped." || echo "FinAlly is not running."
docker rm "$CONTAINER_NAME" 2>/dev/null || true
```

**scripts/start_windows.ps1:**
```powershell
$ErrorActionPreference = "Stop"
$ContainerName = "finally"
$ImageName = "finally"

# Stop existing container if running
docker rm -f $ContainerName 2>$null

# Build if --build flag passed or image doesn't exist
if ($args -contains "--build" -or -not (docker image inspect $ImageName 2>$null)) {
    Write-Host "Building FinAlly Docker image..."
    docker build -t $ImageName .
}

# Run container
docker run -d `
    --name $ContainerName `
    -p 8000:8000 `
    -v finally-data:/app/db `
    --env-file .env `
    $ImageName

Write-Host ""
Write-Host "FinAlly is running at http://localhost:8000"
Write-Host "Stop with: .\scripts\stop_windows.ps1"
```

**scripts/stop_windows.ps1:**
```powershell
$ErrorActionPreference = "Stop"
$ContainerName = "finally"

docker stop $ContainerName 2>$null
if ($?) { Write-Host "FinAlly stopped." } else { Write-Host "FinAlly is not running." }
docker rm $ContainerName 2>$null
```

Make bash scripts executable: chmod +x scripts/start_mac.sh scripts/stop_mac.sh
  </action>
  <verify>
Run: ls -la scripts/ (all 4 scripts exist)
Run: file scripts/start_mac.sh (should show "Bourne-Again shell script" or similar executable text)
Run: bash -n scripts/start_mac.sh && bash -n scripts/stop_mac.sh (syntax check passes)
  </verify>
  <done>
Four scripts exist in scripts/: start_mac.sh (executable), stop_mac.sh (executable), start_windows.ps1, stop_windows.ps1. Bash scripts pass syntax check. All scripts are idempotent (safe to run multiple times). Scripts use consistent container name "finally" and image name "finally".
  </done>
</task>

</tasks>

<verification>
1. docker build -t finally . completes without errors
2. docker run --rm -d --name finally-verify -p 8000:8000 -e LLM_MOCK=true finally
3. curl http://localhost:8000/api/health returns {"status":"healthy"}
4. curl -s http://localhost:8000/ returns HTML (the Next.js frontend)
5. docker stop finally-verify && docker rm finally-verify
6. All 4 scripts exist and bash scripts pass syntax validation
7. .env.example, .dockerignore, docker-compose.yml exist at project root
</verification>

<success_criteria>
- Multi-stage Dockerfile builds the Next.js frontend (Stage 1) and packages it with the Python backend (Stage 2) into a single image
- Running the container on port 8000 serves the full application: static frontend at /, API endpoints at /api/*, SSE at /api/stream/prices
- docker-compose.yml provides a convenience wrapper with named volume "finally-data" and healthcheck
- .env.example documents all environment variables
- Start/stop scripts exist for both macOS/Linux and Windows
</success_criteria>

<output>
After completion, create `.planning/phases/10-packaging-testing/10-01-SUMMARY.md`
</output>
