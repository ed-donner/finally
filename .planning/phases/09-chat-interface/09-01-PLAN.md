---
phase: 09-chat-interface
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/stores/chat-store.ts
  - frontend/src/components/panels/ChatPanel.tsx
autonomous: true

must_haves:
  truths:
    - "AI chat panel is visible as a docked sidebar on the right"
    - "User can type a message and send it to the AI"
    - "Loading indicator shows while waiting for AI response"
    - "Conversation history scrolls and displays user and assistant messages with distinct styling"
    - "AI-executed trades appear inline as structured action confirmation cards"
    - "AI watchlist changes appear inline as structured action confirmation cards"
    - "Portfolio and watchlist panels refresh automatically after AI-driven actions"
    - "Chat panel can be collapsed to a minimal toggle strip and re-expanded"
  artifacts:
    - path: "frontend/src/stores/chat-store.ts"
      provides: "Chat state management with sendMessage action"
      exports: ["useChatStore"]
    - path: "frontend/src/components/panels/ChatPanel.tsx"
      provides: "Full chat UI replacing placeholder"
      exports: ["ChatPanel"]
  key_links:
    - from: "frontend/src/components/panels/ChatPanel.tsx"
      to: "frontend/src/stores/chat-store.ts"
      via: "useChatStore selectors"
      pattern: "useChatStore\\("
    - from: "frontend/src/stores/chat-store.ts"
      to: "/api/chat"
      via: "fetch POST in sendMessage"
      pattern: "fetch.*api/chat"
    - from: "frontend/src/stores/chat-store.ts"
      to: "frontend/src/stores/portfolio-store.ts"
      via: "cross-store refresh after executed trades"
      pattern: "usePortfolioStore\\.getState\\(\\)"
    - from: "frontend/src/stores/chat-store.ts"
      to: "frontend/src/stores/watchlist-store.ts"
      via: "cross-store refresh after watchlist changes"
      pattern: "useWatchlistStore\\.getState\\(\\)"
---

<objective>
Build the AI chat panel: a Zustand store for chat state and a full ChatPanel component replacing the current placeholder. The panel supports sending messages, displaying conversation history with distinct user/assistant styling, showing loading state, rendering inline action confirmation cards for AI-executed trades and watchlist changes, and collapsing to a narrow toggle strip.

Purpose: Completes the chat interface requirement (FE-CHAT-01 through FE-CHAT-05) -- the final interactive feature before Docker packaging.
Output: Working chat sidebar that communicates with POST /api/chat and refreshes portfolio/watchlist after AI actions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-chat-interface/09-RESEARCH.md
@frontend/src/stores/portfolio-store.ts
@frontend/src/stores/watchlist-store.ts
@frontend/src/stores/price-store.ts
@frontend/src/components/panels/WatchlistPanel.tsx
@frontend/src/components/panels/ChatPanel.tsx
@frontend/src/app/page.tsx
@frontend/src/app/globals.css
@backend/app/llm/models.py
@backend/app/llm/router.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat Zustand store</name>
  <files>frontend/src/stores/chat-store.ts</files>
  <action>
Create `frontend/src/stores/chat-store.ts` following the exact Zustand pattern used in `portfolio-store.ts` and `watchlist-store.ts`.

Define TypeScript interfaces matching the backend response contract from `backend/app/llm/models.py`:

```typescript
interface TradeResult {
  status: string;    // "executed" | "failed"
  ticker: string;
  side: string;      // "buy" | "sell"
  quantity: number | null;
  price: number | null;
  total: number | null;
  error: string | null;
}

interface WatchlistResult {
  status: string;    // "applied" | "failed"
  ticker: string;
  action: string;    // "add" | "remove"
  error: string | null;
}

interface ChatMessage {
  role: "user" | "assistant";
  content: string;
  trades?: TradeResult[];
  watchlist_changes?: WatchlistResult[];
}
```

Store interface:
```typescript
interface ChatStore {
  messages: ChatMessage[];
  sending: boolean;
  error: string | null;
  sendMessage: (message: string) => Promise<void>;
}
```

The `sendMessage` action must:
1. Add the user message to `messages` immediately (optimistic) with `{ role: "user", content: message }`
2. Set `sending: true`, clear `error: null`
3. POST to `/api/chat` with `{ message }` (Content-Type: application/json)
4. On success (res.ok): parse JSON, add assistant message to `messages` with `{ role: "assistant", content: data.message, trades: data.trades, watchlist_changes: data.watchlist_changes }`
5. After adding assistant message, trigger cross-store refresh:
   - If `data.trades?.some(t => t.status === "executed")`: call `usePortfolioStore.getState().fetchPortfolio()` and `usePortfolioStore.getState().fetchHistory()`
   - If `data.watchlist_changes?.some(w => w.status === "applied")`: call `useWatchlistStore.getState().fetchWatchlist()`
6. Set `sending: false`
7. On fetch error (network failure or !res.ok): keep the user message in the list (do NOT remove it), add an error message `{ role: "assistant", content: "Failed to get a response. Please try again." }`, set `sending: false`

Export: `export const useChatStore = create<ChatStore>()(...)`.
Import `usePortfolioStore` from `@/stores/portfolio-store` and `useWatchlistStore` from `@/stores/watchlist-store` for cross-store access.
  </action>
  <verify>
Run `cd /Users/ed/projects/finally/frontend && npx tsc --noEmit` -- no type errors in chat-store.ts.
  </verify>
  <done>
chat-store.ts exports useChatStore with messages array, sending boolean, error string, and sendMessage action that POSTs to /api/chat and triggers cross-store refreshes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build full ChatPanel component with collapsible sidebar and inline action cards</name>
  <files>frontend/src/components/panels/ChatPanel.tsx</files>
  <action>
Replace the placeholder `ChatPanel.tsx` with a full chat interface. Use `"use client"` directive. Import `useChatStore` from `@/stores/chat-store`.

**Structure** (flex column filling full height, same pattern as WatchlistPanel):

```
<div className="h-full w-full flex flex-col bg-terminal-surface">
  Header bar (with collapse toggle)
  Message list (flex-1 min-h-0 overflow-y-auto, scrollable)
  Input area (pinned at bottom)
</div>
```

**Collapsed state:**
- Use `useState<boolean>(true)` for `isOpen` (starts open).
- When collapsed, render a narrow vertical strip with just the text "AI Chat" rotated or a small toggle button. Something like:
```tsx
if (!isOpen) {
  return (
    <div className="h-full w-full bg-terminal-surface flex flex-col items-center pt-3 cursor-pointer"
         onClick={() => setIsOpen(true)}>
      <span className="font-mono text-xs text-text-muted uppercase tracking-wider [writing-mode:vertical-lr]">
        AI Chat
      </span>
    </div>
  );
}
```

**Header bar:**
- Label: "AI Assistant" in `font-mono text-xs uppercase tracking-wider text-text-muted`
- Collapse button on the right: a small button (e.g., "x" or chevron icon using plain text characters) that sets `isOpen` to false. Use `text-text-muted hover:text-brand-blue`.

**Message list:**
- Container: `flex-1 min-h-0 overflow-y-auto px-3 py-2 space-y-3`
- Map over `messages` from `useChatStore`.
- User messages: right-aligned, with a bubble styled `bg-brand-purple/20 border border-brand-purple/40 rounded-lg px-3 py-2 inline-block max-w-[85%] ml-auto`
- Assistant messages: left-aligned, with a bubble styled `bg-terminal-bg border border-terminal-border rounded-lg px-3 py-2 inline-block max-w-[85%]`
- All text in `font-mono text-xs text-text-primary` with `whitespace-pre-wrap` for line breaks.
- Role label above each bubble: "You" / "FinAlly" in `text-text-muted font-mono text-[10px] mb-0.5`

**Inline action confirmation cards** (inside assistant message bubbles, below the text):
- For each trade in `msg.trades` where `status === "executed"`:
  ```
  <div className="mt-2 p-2 rounded bg-terminal-surface border border-terminal-border text-xs font-mono">
    <span className={side === "buy" ? "text-price-up" : "text-price-down"}>
      {side.toUpperCase()}
    </span> {quantity} {ticker} @ ${price?.toFixed(2)} = ${total?.toFixed(2)}
  </div>
  ```
- For each trade where `status === "failed"`:
  ```
  <div className="mt-2 p-2 rounded bg-price-down/10 border border-price-down/30 text-xs font-mono text-price-down">
    Failed: {side} {ticker} -- {error}
  </div>
  ```
- For each watchlist change where `status === "applied"`:
  ```
  <div className="mt-2 p-2 rounded bg-terminal-surface border border-terminal-border text-xs font-mono text-brand-blue">
    {action === "add" ? "+" : "-"} {ticker} {action === "add" ? "added to" : "removed from"} watchlist
  </div>
  ```
- For each watchlist change where `status === "failed"`:
  ```
  <div className="mt-2 p-2 rounded bg-price-down/10 border border-price-down/30 text-xs font-mono text-price-down">
    Watchlist: failed to {action} {ticker} -- {error}
  </div>
  ```

**Loading indicator** (shown when `sending === true`, below the last message):
- Three pulsing dots with "Thinking..." text:
  ```
  <div className="flex items-center gap-1 px-1 py-2">
    <span className="w-1.5 h-1.5 bg-brand-blue rounded-full animate-pulse" />
    <span className="w-1.5 h-1.5 bg-brand-blue rounded-full animate-pulse [animation-delay:150ms]" />
    <span className="w-1.5 h-1.5 bg-brand-blue rounded-full animate-pulse [animation-delay:300ms]" />
    <span className="font-mono text-xs text-text-muted ml-2">Thinking...</span>
  </div>
  ```

**Auto-scroll:**
- Use `useRef<HTMLDivElement>(null)` for `messagesEndRef`.
- Place `<div ref={messagesEndRef} />` at the bottom of the message list.
- `useEffect` that runs when `messages` changes: call `messagesEndRef.current?.scrollIntoView({ behavior: "smooth" })`.
- Only auto-scroll if user is near the bottom (within 100px). Check the scroll container's `scrollHeight - scrollTop - clientHeight < 100` before scrolling. Store the scroll container ref separately.

**Input area:**
- Container: `p-2 border-t border-terminal-border`
- Form with `onSubmit` handler that calls `sendMessage(input)` then clears input.
- Text input: `flex-1 bg-terminal-bg border border-terminal-border rounded px-2 py-1.5 font-mono text-xs text-text-primary placeholder:text-text-muted focus:outline-none focus:border-brand-blue`
- Placeholder: "Ask FinAlly..."
- Send button: `bg-brand-purple hover:bg-brand-purple/80 text-text-primary font-mono text-xs px-3 py-1.5 rounded transition-colors disabled:opacity-50`
- Disable both input and send button when `sending === true`.
- Clear input immediately on submit (before the async call completes).
- Also support Enter key to send (this is automatic with form onSubmit).

**Empty state** (when messages.length === 0 and not sending):
- Show a centered welcome message: "Ask me about your portfolio, request trades, or manage your watchlist." in `text-text-muted font-mono text-xs text-center px-4`.
  </action>
  <verify>
Run `cd /Users/ed/projects/finally/frontend && npx tsc --noEmit` -- no type errors. Then `cd /Users/ed/projects/finally/frontend && npm run build` -- static export succeeds.
  </verify>
  <done>
ChatPanel replaces placeholder with full chat UI: collapsible sidebar, message history with distinct user/assistant styling, inline action cards for trades and watchlist changes, loading indicator, auto-scroll, and input form with send button.
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/ed/projects/finally/frontend && npx tsc --noEmit` passes with zero errors
2. `cd /Users/ed/projects/finally/frontend && npm run build` produces successful static export
3. Visual inspection: ChatPanel renders in the right column of the terminal grid
4. Functional check: typing a message and pressing send/Enter adds a user bubble, shows loading dots, and (when backend is running) displays the AI response with inline action cards
</verification>

<success_criteria>
1. AI chat panel is visible as a docked sidebar in the rightmost 3 columns of the terminal grid
2. Panel can be collapsed to a narrow vertical strip and re-expanded by clicking
3. User can type a message and send it; input clears immediately and a loading indicator appears
4. User messages render right-aligned with purple tint; assistant messages render left-aligned with dark background
5. AI-executed trades render as structured cards showing side, quantity, ticker, price, and total
6. Failed trades render as red-tinted cards with error text
7. Watchlist changes render as blue-tinted cards showing add/remove action
8. Portfolio and watchlist stores refresh automatically when AI executes trades or watchlist changes
9. Message list auto-scrolls to bottom on new messages (unless user has scrolled up)
10. The frontend builds successfully as a static export
</success_criteria>

<output>
After completion, create `.planning/phases/09-chat-interface/09-01-SUMMARY.md`
</output>
